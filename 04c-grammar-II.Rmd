# Grammer of layered graphics II

```{r, include=FALSE, message=FALSE}
source("common.R")
library(tidyverse)

acs_messy <- read_csv("data/ACS_1317_TRACT.csv")

acs <- acs_messy %>% 
  separate(name, sep = ", ", into = c("tract", "county", "state")) %>% 
  mutate(tract = str_remove(tract, "Census Tract ")) %>% 
  na.omit()
```

We've developed a strong foundation for building charts from the ground up by specifying our **defaults** (data, and aesthetic mappings), and adding geom **layers**. In order to take our charts to the next level we need to familiarize ourselves with the other components of the _Layered Grammar of Graphics_: scales, coordinates, and facets.

## Scales 

Recall from _[Grammar of Layered Graphics I](#layered-i)_ that when we supply our aesthetic mappings our axes are filled out automatically.

```{r}
(p <- ggplot(acs, aes(med_house_income, bach)))
```

By specifying our defaults in the `ggplot()` call, we implicitly are providing the x and y axes. From those mappings, ggplot2 is able to identify the type of variable mapped to each aesthetic and its values. That inference makes it possible for us to plot without having to explicitly state what our axes are.

```{r}
p <- ggplot(acs, aes(med_house_income, bach)) +
  geom_point(size = 1/3)
```

In the above chart, each column is being mapped as a continuous variable. We are able to manually specify what each scale type is by using the various `scale_*_type()` layers from ggplot2. These layers follow a general format of first specifying `scale` followed by which aesthetic we're scaling, and what data type. For example, to change the `med_house_income` axis to a discrete axis we can apply the layer `scale_x_discrete()`

```{r}
p +
  scale_x_discrete() 
```

In doing so we have lost the axis labels! That is because ggplot2 considers both integers and floating point (numbers with decimals) as continuous and categorical variables as being discrete. 

Nonetheless, we have a lot of functions at our disposal to alter the axes to our liking!

### Transformations

In our data exploration, we will come across non-normal distributions of data.

- income is almost always right skewed displaying some sort of log-normal-ish behavior. 
- we may not want to actually change to underlying values of that variable, but want to apply transformations for the purposes of visualization
- in that case, we can apply scale transformations
- in our visualization of income and education, there is a slight right skew to `med_house_income`
  - it doesn't justify a logarithmic transformation, but may benefit from a sqrt transformation
  - we can apply this with `scale_x_sqrt()`

```{r}
p +
  scale_x_sqrt() 
```

We can apply a log10 transformation as well with `scale_*_log10()`.

```{r}
p +
  scale_x_log10() 
```

This is an overcorrection. The slight upward arch in the original plotting is now inverted. Nonetheless, I hope the point is made. 

In addition to applying transformations, we will want to have more control over the limits of our graph. For example, say we want to have our y axis include all _possible_ values of [0,1]. We can tell ggplot what range of values we want our axes to contain with `lims()`. `lims()` takes a name-value pair where the name is an aesthetic and the value is a numeric vector with two elements—the first being the value at the origin and the second being at the extent of the axis[^lims].

> Note: [0,1] means from 0 inclusive to 1 inclusive. 

We can modify our y axis to have the limits of [0,1] by adding a `lims()` layer where we set the `y` aesthetic to `c(0, 1)`.

```{r}
p +
  lims(y = c(0, 1))
```

The graph we get we when expand our y axis limits definitely contains a bit too much white space. But by expanding ths grid, we can see this sort of flattening out of education at around $150,000 while income still continues to increase. Perhaps if we omit tose values, the relationship may seem even stronger. Let's experiment with that.


* Set the x axis limit to be from [0, 150000]
* Set the y axis limits to be from [0, 0.5]

```{r warning=FALSE}
p +
  lims(
    x = c(0, 150000),
    y = c(0, .5)
    )
```

By changing the extent of our axes this relationship seems much more robust! Such a visualization could spur further validation of this ACS data.

> Remember, ACS data come from samples and sometimes those samples are small. Because of these small sample sizes, we may very well get values that are not properly representative. It is on you to decide whether or not you should include or exclude the values!

### Labeling

The plots we create, while lovely as they are, are somewhat lacking in the labeling department. I would put money on it that no publication would accept plots with labels such as the ones above for sole reason being that our axes titles and scale labels are hard to interpret. 

We've already used it befofe but to be extra clear, to add titles and axis labels to our plots (not adjusting the scale labels) we use a `labs()` layer. With `labs()`, you can label any aesthetic you have mapped as well as adding a `title`, `subtitle`, `caption`, and a `tag`.

Let's add some titles and labels to our plot.

```{r}
p <- ggplot(acs, aes(med_house_income, bach)) +
  geom_point(size = 1/3) +
    labs(
       y = "% of population with a Bachelor's Degree",
       x = "Median Household Income",
       title = "Relationship between Education and Income",
       subtitle = "All Massachusetts Tracts",
       caption = "Source: Boston Area Research Initiative\nvia US Census Bureau"
      )

p
```

Friends, it's looking pretty good. But there are just two more changes we need to make: our axes labels! The x and y axes labels are meant to illustrate dollar amounts and percentages but respectively. To change the _scale_ labels. we will use some helper functions from the package [`scales`](https://scales.r-lib.org/)

{scales} provides handy functions for taking a variable and altering the labeling to match some other format. In our case, we are interested in printing our `med_house_income` as in a dollar format, i.e. `2000` becomes `\$2,000`, and `bach` as a percentage, i.e. `.4` becomes `%40`. To alter our labels we will use `scales::dollar()`, and `scales::percent()` respectively.

> Isn't it nice how well named functions can be sometimes?

To produce the examples outlined above we would call the function as such:

```{r}
scales::dollar(2000)
scales::percent(.4)
```

Now we have an understanding of _how_ the function behaves, but where do we actually change the labels? This is where we come full cirlce back to our `scale_*_continuous()` layer. As we mentioned earlier, `ggplot()` will handle making the scales for us. But `ggplot()` doesn't know how we want to label our variables or how they should appear on the axes. And now the impetus is on us to make these changes manually. To change the axis labels we will specify which axis we are altering using the proper scale layer—i.e. `scale_y_` or `scale_x_`. Then, in each layer we set the `labels` argument to the respective labelling function we want—e.g. `scales::percent` and `scales::dollar`.

> Note: If you append parentheses like you normally would you will get an error. This case we want to ignore them because when they are present, R will try to evaluate that function. Rather, we are interested in providing the _function object_ to the `labels` argument rather than provide it with a vector of output. 

```{r}
p + 
  scale_x_continuous(labels = scales::dollar) + 
  scale_y_continuous(labels = scales::percent)
```

In addition to being able to control the **defaults**, the **layers**, and now the **scales** you are well equipped to create and manipulate your own plots. 

## Coordinates

While you're likely to create 98% of your visualizations without ever manipulating the coordinates, it is still good knowledge to have! 

As we have mentioned and alluded to, we are working in a two-dimensional space—meaning with x and y coordinates. When working in two-dimensions, thee cartesian plane is the natural choice for a coordinate reference system. In all of our plots, this has been the default. Behind the scenes, ggplot is essentially adding a `coord_cartesian()` layer to your plot.

> Think of this much of the same way that your scales are inferred.

If, however, we find the need to alter or manipulate the coordinate system the tools are available to us. We've actually already used one, `coord_flip()`. Like, with scales, all coordinate based functions are prefixed with `coord_()`.

You're most likely 

## Facets


`facet_wrap()`
`facet_grid()`





It is also important to note that what we have gone through is by no means exhaustive. You should, at minimum, familiarize yourself with both `scale_*_reverse()`, and `scale_*_binned()` in your spare time. There are dozens, if not hundreds, of ggplot2 functions to suit your every whim. And, as you have already briefly seen, the ggplot function universe is not relegated to just ggplot2. There are many other packages which have built custom geoms and other enhancements that may benefit you. 


[^lims]: https://ggplot2.tidyverse.org/reference/lims
  