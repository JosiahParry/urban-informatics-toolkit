[
["creating-new-measures.html", "Chapter 9 Creating new measures", " Chapter 9 Creating new measures It’s been a week now and the non-profit has finally emailed you back. They were ecstatic with what you provided but it begat even more questions for them. They indicated that while the median household income data was very intruiging, that would be difficult for them to report on. As such, they would like you to report on the income quintiles as well. Moreover, they also would like to see the rate of Bachelor’s and Master’s degrees combined into one general educational attainment variable. This poses some challenges for you. You know what is being asked, just not necessarily how to achieve that from R. To accomplish this we’re going to have to learn how to use the dplyr::mutate() function. For the sake of example, let’s select only the columns that we’re going to need and make a tibble called df just to work with. library(tidyverse) commute &lt;- read_csv(&quot;data/gba_commute.csv&quot;) df &lt;- select(commute, med_house_income, bach, master) df #&gt; # A tibble: 648 x 3 #&gt; med_house_income bach master #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 75085 0.188 0.100 #&gt; 2 132727 0.400 0.130 #&gt; 3 110694 0.317 0.139 #&gt; 4 109125 0.322 0.144 #&gt; 5 76746 0.177 0.0742 #&gt; 6 138700 0.310 0.207 #&gt; 7 104673 0.247 0.149 #&gt; 8 73191 0.300 0.126 #&gt; 9 121488 0.198 0.140 #&gt; 10 99358 0.348 0.151 #&gt; # … with 638 more rows mutate() is a function that let’s us create or modify variables. The arguments for mutate() are the same as those for select()—.data and .... In the case of mutate() dots works a littble bit differently. After indicating our data, we create columns by specifying a name-value pair. More simply the names of our arguments will be the name of the columns that we are creating. The value is any expression. For example we could use mutate(df, one = 1) to create a column called one with the value of 1. When using mutate, however, the result from the expression needs to be either only one value, or as many values as there are rows. If we take our df, we can add the columns bach and master together to create a new column called edu_attain. mutate(df, edu_attain = bach + master) #&gt; # A tibble: 648 x 4 #&gt; med_house_income bach master edu_attain #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 75085 0.188 0.100 0.288 #&gt; 2 132727 0.400 0.130 0.531 #&gt; 3 110694 0.317 0.139 0.456 #&gt; 4 109125 0.322 0.144 0.466 #&gt; 5 76746 0.177 0.0742 0.251 #&gt; 6 138700 0.310 0.207 0.516 #&gt; 7 104673 0.247 0.149 0.396 #&gt; 8 73191 0.300 0.126 0.426 #&gt; 9 121488 0.198 0.140 0.338 #&gt; 10 99358 0.348 0.151 0.499 #&gt; # … with 638 more rows We could even think about ways that we can check if some observations are above some specified income threshold. mutate(df, above_70k_inc = med_house_income &gt; 80000) #&gt; # A tibble: 648 x 4 #&gt; med_house_income bach master above_70k_inc #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; #&gt; 1 75085 0.188 0.100 FALSE #&gt; 2 132727 0.400 0.130 TRUE #&gt; 3 110694 0.317 0.139 TRUE #&gt; 4 109125 0.322 0.144 TRUE #&gt; 5 76746 0.177 0.0742 FALSE #&gt; 6 138700 0.310 0.207 TRUE #&gt; 7 104673 0.247 0.149 TRUE #&gt; 8 73191 0.300 0.126 FALSE #&gt; 9 121488 0.198 0.140 TRUE #&gt; 10 99358 0.348 0.151 TRUE #&gt; # … with 638 more rows This function is immensly useful and can be combined with almost any expression to create new data for us. Furthermore there are a number of handy functions built into dplyr that help us create new columns. Some of these are case_when(), min_rank(), and ntile() among others. You can always explore these with ?function_name(). For our purposes, we will look at the use of ntile(). ntile() is a function that will calculate percentiles for us. Given a column of data, x, and a number of buckets, n, we can create a new column of ranks. In our case, we are interested in calculating the quintile of med_house_income. This means we can provide med_house_income and n = 5 as arguments to ntile() to group our observations by quintile. mutate(df, inc_quintile = ntile(med_house_income, 5)) #&gt; # A tibble: 648 x 4 #&gt; med_house_income bach master inc_quintile #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 75085 0.188 0.100 2 #&gt; 2 132727 0.400 0.130 5 #&gt; 3 110694 0.317 0.139 4 #&gt; 4 109125 0.322 0.144 4 #&gt; 5 76746 0.177 0.0742 2 #&gt; 6 138700 0.310 0.207 5 #&gt; 7 104673 0.247 0.149 4 #&gt; 8 73191 0.300 0.126 2 #&gt; 9 121488 0.198 0.140 5 #&gt; 10 99358 0.348 0.151 4 #&gt; # … with 638 more rows Now we can put everything together into one mutate call to create the new variables that were requested! updated_commute &lt;- commute %&gt;% mutate(edu_attain = bach + master, inc_quintile = ntile(med_house_income, 5)) As you have made these changes you can now write the data again to csv and share it. As this process becomes more and more iterative, it’s good to put some structure to the data so you have an idea of the history. One general practice that is good to get into is dating your files. So in this case I would label the file yyyy-mm-dd-commute.csv. "]
]
