[
["visualizing-trends-and-relationships.html", "Chapter 9 Visualizing Trends and Relationships 9.1 The Grammar of Layered Graphics 9.2 Layers and defaults 9.3 Scales 9.4 Coordinates 9.5 Facets 9.6 Univariate visualizations 9.7 Bivariate visualizations 9.8 Expanding bivariate visualizations to trivariate &amp; other tri-variate", " Chapter 9 Visualizing Trends and Relationships library(tidyverse) ## ── Attaching packages ────────────────────────────────────────── tidyverse 1.2.1 ── ## ✓ tibble 2.1.3 ✓ purrr 0.3.3 ## ✓ tidyr 1.0.2 ✓ dplyr 0.8.3 ## ✓ readr 1.3.1 ✓ stringr 1.4.0 ## ✓ tibble 2.1.3 ✓ forcats 0.4.0 ## ── Conflicts ───────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() acs_messy &lt;- read_csv(&quot;data/ACS_1317_TRACT.csv&quot;) ## Parsed with column specification: ## cols( ## .default = col_double(), ## name = col_character(), ## med_yr_built = col_character(), ## town = col_character(), ## county = col_character(), ## m_atown = col_character() ## ) ## See spec(...) for full column specifications. acs &lt;- acs_messy %&gt;% separate(name, sep = &quot;, &quot;, into = c(&quot;tract&quot;, &quot;county&quot;, &quot;state&quot;)) %&gt;% mutate(tract = str_remove(tract, &quot;Census Tract &quot;)) %&gt;% na.omit() You’ve made it quite far through this book. Now, I want to bring us back to the very beginning. In the first chapter we created a few visualizations with ggplot2. I want to unpack ggplot2 a bit more and also address some of the more philosophical underpinnings of visualization. This chapter introduces you to the idea of the grammar of graphics, discusses when which visualizations are appropriate, and some fundamental design principles follow. 9.1 The Grammar of Layered Graphics The gg in ggplot2 refers to the grammar of graphics (and the 2 is because it’s the second iteration). The Grammar of Graphics (Wilkinson, 1999) is a seminal book in data visualization for the sciences in which, Wilkinson defines a complete system (grammar) for creating visualizations that go beyond the standard domain of “named graphics”—e.g. histogram, barchart, etc.1 ggplot2 is “an open source implementation of the grammar of graphics for R.”2 Once we can internalize the grammar of graphics, creating plots will be an intuitive and artistic process rather than a mechanical one. There are five high level components of the layered grammar3. Defaults: Data Mapping Layer: Data* Mapping* Geom Stat Position Scale Coord Facet 9.2 Layers and defaults In the first chapter of this section we explored these principles but did not put a name to them. Recall that we can use ggplot() by itself and it returns a chart of nothing. ggplot() This is because we have not specified any of the defaults. In order for us to plot anything at all, we need to specify what (the data object) will be visualized, which features (the aesthetic mappings), and how (the geoms). When we begin to specify our x and y aesthetics the scales are interpreted. ggplot(acs, aes(med_house_income, by_auto)) The final step is to add the geom layer which will inherit the data, aesthetic mappings, scale, and position while the geom_*() layer dictates the geometry. ggplot(acs, aes(bach, med_house_income))+ geom_point() While this is the most common way you might define a ggplot, you should also be aware of the fact that each layer can stand on its own without you defining any of the defaults in the ggplot() call. Each geom inherits the defaults from ggplot(), but each geom_*() also has arguments for data, and mapping, providing you with increased flexibility. Note: the geom_*()s have the data as the second argument so either put the data there or name the argument explicitly. The choice is yours. Choose wisely! What happens if we provide all of this information to geom_point() and entirely omit ggplot()? geom_point(aes(med_house_income, by_auto), acs) ## mapping: x = ~med_house_income, y = ~by_auto ## geom_point: na.rm = FALSE ## stat_identity: na.rm = FALSE ## position_identity We see that we do not have the plot, but we do have all of the information required of a layer is printed out to the console. If we add an empty ggplot call ahead of the layer, we will be able to create the plot. ggplot() + geom_point(aes(med_house_income, by_auto), acs) Being able to specify different data objects within each layer will provie to be extraordinarily helpful when we begin to work with spatial data, or plotting two different data frames with the same axes, or any other creative problem you wish to solve. 9.3 Scales 9.4 Coordinates 9.5 Facets Notes we specify data and mappings, nothing is displayed at that time from the defaults we can see that the scales and coordinates are intuitively handled the default coordinate system is the cartesian coordinate system which has two axes x (horizontal), and y (vertical) in order to see the data, we needed to add geometry to our base layer when we add Geoms to the graphic the data and aesthetic mappings are inherited from the defaults we do not necessarily need to default data if we do not feel the need to do so. we can specify the data and mappings inside of the geom layer itself this will be handy when we work with geospatial data stat refers to statistical transformations. often you will not need to apply transformations to your data as their identity (assigned values) are sufficient. recommended reading: A Layered Grammar of Graphics in R we will use a package called ggplot2 to do the visualizaiton of our data the gg in ggplot stands for “grammar of graphics”. once we can internalize the grammar, creating plots becomes rather easy we specify our aesthetics we add layers (hence the plus sign). these take values from the specified aesthetics can add multiple layers add aesthetics other than x and y. helps us visualize more dimensions of the data. we can use shape, color, and size 9.5.1 revisiting the cartesian plane x and y coordinates generally two numeric values on the x and y. think of the standards scatterplot (below) we also can place groups on one axis i.e. barchart (below) the y is usually the variable of interest as we move along the x axis (to the right) we can see how the y changes in response most data analyses start with a visualization. the data we have will dictate the type of visualizations we create there are many many different ways in which data can be represented generally these can be bucketed into a few major categories numeric integer double character think groups, factors, nominal, anything that doesn’t have a numeric value that makes sense to count, aggregate, etc. time / order 9.6 Univariate visualizations what are we looking for in univariate visualizations? the shape of the distribution measures of central tendency where do the data cluster? is there a center? more than one? how much variation is in the data? is the distribution flatter or steeper? 9.6.1 histogram puts data into n groups or bins or buckets. ggplot calls them bins you can identify how many obs fit into a bucket ggplot(acs, aes(age_u18)) + geom_histogram(bins = 15) 9.6.2 density plot A density plot is a representation of the distribution of a numeric variable visualizes the distribution of data over a continuous interval it’s called a density plot because it uses a kernel density. you do not need to know what this is, just that it shows a continuous representation of the distribution unlike histograms you cannot determine how many obs fall in a bucket as there are no buckets. ggplot(acs, aes(age_u18)) + geom_density() 9.6.3 box plot box plots are another way to show the distribution unlike histograms and density plots which show the shape of the distribution box plots are concerned with illustrating any potential outliers aside: an outlier is a value that differs substantially from other obs based on 5 summary values: the first quartile median (the middle value) the third quartile the minimum and the maximum: these aren’t actually the max and min, these are we have to set this aesthetic to y refs: https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51 ggplot(acs, aes(y = age_u18)) + geom_boxplot() its easier to evaluate a box plot when it’s horizontal. we can flip any ggplot with a coord_flip() layer ggplot(acs, aes(y = age_u18)) + geom_boxplot() + coord_flip() 9.6.3.1 understanding the box plot 9.7 Bivariate visualizations with bi-variate relationships we’re looking to answer, in general, if one variable affects the other. we usually will be comparing two numeric variables or one numeric and one categorical variable in the former situtation we’re looking to see if there is a related trend, i.e. when one goes up does the other go down or vice versa in the latter scenario, we want to know if the distribution of the data changes for different groups 9.7.1 scatter plot (2 continuous) we made one previously this is two continuous on each axis. the variable of interest is on the y example: we can hypothesize that where there are more under 18 there are more families we can ask how does the prop of population under 18 vary with prop of family households? when there are many points (which is often the case w/ big data) we can change the transparency (often called opacity) so we can see where there is the most overlap. Inside of the geom_point() we set the alpha argument to a value between 0 and 1 where 1 is not transparent and 0 is invisible. this is artistic preference and there is no one true answer ggplot(acs, aes(fam_house_per, age_u18)) + geom_point(alpha = 0.25) 9.7.2 boxplot (1 continuous 1 categorical) we can use boxplots to compare groups for this, we set the categorical variable to the x aesthetic ggplot(acs, aes(county, age_u18)) + geom_boxplot() + coord_flip() 9.7.3 barplot (1 categorical 1 continuous / discrete) the geom_bar() will count the number observations of the specified categorical variables ggplot(acs, aes(county)) + geom_bar() + coord_flip() 9.7.4 lollipop chart barplot’s more fun cousin, the lollipop chart the package ggalt makes a geom for us so we don’t have to create it manually we do, however, have to count the observations ourself. we use the function count() to do this. the arguments are x, or the tibble, and ... these are the columns we want to count important note: in the tidyverse, the first argument is almost always the tibble we are working with this will become very useful at a later point remember, to install packages, navigate to the console and use the function install.packages(&quot;pkg-name&quot;). library(ggalt) ## Registered S3 methods overwritten by &#39;ggalt&#39;: ## method from ## grid.draw.absoluteGrob ggplot2 ## grobHeight.absoluteGrob ggplot2 ## grobWidth.absoluteGrob ggplot2 ## grobX.absoluteGrob ggplot2 ## grobY.absoluteGrob ggplot2 acs_counties &lt;- count(acs, county) ggplot(acs_counties, aes(county, n)) + geom_lollipop() + coord_flip() ridgelines (1 continuous 1 categorical) line chart (1 continuous 1 time), this is a unique case 9.8 Expanding bivariate visualizations to trivariate &amp; other tri-variate we can visualize other vcariables by setting further aesthetics. can set the color or fill, size, and shape we alreay did this previously when we set the color, let’s do that here. lets see how commuting by walking changes with the family house and under 18 pop set the color argument of the aes() function as color = by_walk it’s important you do this within the aesthetics function ggplot(acs, aes(fam_house_per, age_u18, color = by_auto)) + geom_point() we can add size to this as well by setting the size aesthetic lets see if the more female headed house holds there are affects commuting by car as minors increases ggplot(acs, aes(fam_house_per, age_u18, color = by_auto, size = fem_head_per)) + geom_point(alpha = .2) from this chart we can see quite a few things: as fam_house_per increases so does the under 18 pop, as both age_u18 and fam_house_per increase so does the rate of communiting by car as both age_u18 and fam_house_per so does female headed houses, but to a lesser degree this gives us a good idea of some relationships that we can test with our data at a later point minors_lm &lt;- lm(age_u18 ~ fam_house_per + by_auto + fem_head_per, data = acs) huxtable::huxreg(minors_lm) ## Registered S3 methods overwritten by &#39;broom.mixed&#39;: ## method from ## augment.lme broom ## augment.merMod broom ## glance.lme broom ## glance.merMod broom ## glance.stanreg broom ## tidy.brmsfit broom ## tidy.gamlss broom ## tidy.lme broom ## tidy.merMod broom ## tidy.rjags broom ## tidy.stanfit broom ## tidy.stanreg broom (1) (Intercept) 0.000&nbsp;&nbsp;&nbsp;&nbsp; (0.006)&nbsp;&nbsp;&nbsp; fam_house_per 0.245 *** (0.009)&nbsp;&nbsp;&nbsp; by_auto 0.016 *&nbsp;&nbsp; (0.007)&nbsp;&nbsp;&nbsp; fem_head_per 0.257 *** (0.012)&nbsp;&nbsp;&nbsp; N 1311&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R2 0.564&nbsp;&nbsp;&nbsp;&nbsp; logLik 2444.648&nbsp;&nbsp;&nbsp;&nbsp; AIC -4879.296&nbsp;&nbsp;&nbsp;&nbsp; *** p &lt; 0.001; ** p &lt; 0.01; * p &lt; 0.05. Trivariate: grouped / stacked bar charts heatmaps Color Ramps: diverging when there is a true middle dark is low bright is high "]
]
